#!/bin/bash
#--------------------------------------------------------------------------
# gitdiff
#	Utility to facilitate development with GIT
#	Copyright (c) 2010-2014, Michael Paquier
#
#	See the help to get an idea of the possibilities...
#--------------------------------------------------------------------------

#TODO:
#1) add compatibility for kde and xterm
#2) improve error management... with better error number and an elog api

#List of parameters
BRANCH_MASTER=master
CODE_REPO=$HOME/pgxc
OUTPUT_FILE_NAME=output
TAB_NUMBER=10

#Editor chosen
EDITOR="emacs -nw"

#Option flags
AFLAG=0
FFLAG=0
LFLAG=0
MFLAG=0
PFLAG=0

while getopts 'ab:c:D:e:flm:n:o:p:' OPTION
do
	case $OPTION in
	a)	#Track in repo all untracked files
		AFLAG=1
		;;

	b)	#branch name to compare with master
		BRANCH_NAME="$OPTARG"
		;;

	c)	#checkout a git branch
		CHECKOUT_BRANCH="$OPTARG"
		;;

	D)	#To choose another repo folder
		CODE_REPO="$OPTARG"
		;;

	e)	#Editor chosen
		EDITOR="$OPTARG"
		;;

	f)	#Clean up folder from untracked files
		FFLAG=1
		;;

	l)	#Print list of branch available
		LFLAG=1
		;;

	m)	#Make folder where to put diff files
		#between master branch and chosen branch (could be master itself)
		MFLAG=1
		MAKE_FOLDER="$OPTARG"
		;;

	n)	#Number of files per window
		TAB_NUMBER="$OPTARG"
		;;

	o)	#Output file generated automatically in the code repository
		OUTPUT_FILE_NAME="$OPTARG"
		;;

	p)	#Patch file
		PFLAG=1
		PATCH_FILE="$OPTARG"
		;;

	?)	printf "Usage: %s:\n" $(basename $0) >&2
		printf "	[-a] [-b branch_name] [-D code repository] [-e editor]\n"
		printf "	[-c checkout_branch] [-f] [-l] [-m make folder name]\n"
		printf "	[-n tab_num] [-o outputfile name] [-p patch file name]\n"
		exit 0
		;;
	esac
done

if [ $# -eq "0" ]
then
	echo "No arguments defined"
	exit 0
fi

#Check if editor is well-defined
#Default is emacs no-window
if [ "$EDITOR" != "nano" -a "$EDITOR" != "emacs -nw" -a "$EDITOR" != "vi" ]
then
	echo "Choose an editor between emacs no-window, vi and nano "
	exit 2
fi

CODE_REPO_GIT=$CODE_REPO/.git

if [ ! -d $CODE_REPO_GIT ]
then
	echo "Code repository does not exist or is not git repository"
	exit 2
fi

cd $CODE_REPO

if [ "$LFLAG" = "1" ]
then
	echo "Branch available for this repository"
	git branch -a
	exit 0
fi

if [ "$AFLAG" = "1" ]
then
	echo "Add to repo all the untracked files"
	LIST_FILES=`git ls-files --other --exclude-standard`
	if [ "$LIST_FILES" = "" ]
	then
		echo "No untracked files, no additions"
		exit 0
	fi
	git add $LIST_FILES
	exit 0
fi

if [ "$FFLAG" = "1" ]
then
	echo "Cleaning up folder from untracked files"
	git clean -f
	exit 0
fi

if [ "$CHECKOUT_BRANCH" != "" ]
then
	git checkout $CHECKOUT_BRANCH
	exit 0
fi

if [ ! $(echo "$TAB_NUMBER" | grep -E "^[0-9]+$") ]
then
	echo "Argument -n is not a valid integer"
	exit 2
fi

if [ "$PFLAG" = "1" ]
then
	#Apply chosen patch
	if [ -e $PATCH_FILE ]
	then
		if [ "$BRANCH_NAME" = "" ]
		then
			echo "Patch defined, but no branch defined (-b option)"
			exit 2
		fi

		#Change branch first
		git checkout $BRANCH_NAME;err=$?
		if [ "$err" -ne "0" ]
		then
			echo "Named branch does not exist, create it based on master"
			git branch $BRANCH_NAME $BRANCH_MASTER
			git checkout $BRANCH_NAME
		fi

		#Check Done, apply the patch
		echo "Applying patch $PATCH_FILE"
		patch -p1 < $PATCH_FILE

		#Track new files if there are some in the patch
		LIST_UNTRACKED_FILES=`git ls-files --other --exclude-standard`
		git add $LIST_UNTRACKED_FILES

		#Commit the patch with the patch name as commit log
		echo "Create commit with this patch"
		git commit -a -m "$PATCH_FILE"
		exit 0
	else
		echo "Patch file not defined"
		exit 2
	fi
fi

if [ "$MFLAG" = "1" ]
then
	if [ -d $MAKE_FOLDER ]
	then
		#Take the diff files from the branch and copy it to make folder
		if [ "$BRANCH_NAME" = "" ]
		then
			echo "Branch not defined for file transfer to chosen make folder"
			exit 2
		fi

		#transfer from the branch defined
		git checkout $BRANCH_NAME;err=$?
		if [ "$err" -ne "0" ]
		then
			echo "Named branch does not exist, cannot transfer file"
			exit 2
		fi

		LIST_TRANSFER_FILES=`git diff $BRANCH_MASTER $BRANCH_NAME --name-only`

		for transfer_file in $LIST_TRANSFER_FILES
		do
			echo "cp $CODE_REPO/$transfer_file $MAKE_FOLDER/$transfer_file"
			cp $CODE_REPO/$transfer_file $MAKE_FOLDER/$transfer_file
		done
		echo "File transfer to make folder complete"
		exit 0
	else
		"Make folder not defined"
		exit 2
	fi
fi

#Fallback to the default case, open the files wanted
#Should check if options are well set though...
OUTPUT_FILE=$CODE_REPO/$OUTPUT_FILE_NAME

#checkout the right branch to be sure that what is out corresponds to this branch!!
git checkout $BRANCH_NAME;err=$?
if [ "$err" -ne "0" ]
then
	echo "git checkout error"
	exit $err
fi

#Print out all the file names of this branch
LIST_FILES=`git diff $BRANCH_MASTER $BRANCH_NAME --name-only`

#Open n tabs in 1 window as long as there are files
count=1
count_local=1
file_local=`echo $LIST_FILES |  cut -d " " -f $count`
if [ "$file_local" = '' ]
then
	echo "No files found"
	exit 1
fi

basename_local=`basename $file_local`
command_local="$EDITOR $CODE_REPO/$file_local"
COMMAND="gnome-terminal --window --title $basename_local --command=\"$command_local\""

echo "#!/bin/bash" > $OUTPUT_FILE

#Initialize the command launching the files in each tab
#The format is as follows:
#gnome-terminal --window --title "basename ..." --command "$EDITOR..." --tab --title...
#Each tab has also a name based on the basename of the file_name
while [ "$file_local" != "" ]
do
	count=$((count +1))
	count_local=$((count_local +1))
	file_local=`echo $LIST_FILES |  cut -d " " -f $count`
	if [ "$file_local" = '' ]
	then
		break
	fi
	basename_local=`basename $file_local`
	command_local="$EDITOR $CODE_REPO/$file_local"
	if [ $count_local = $((TAB_NUMBER +1)) ]
	then
		#Save the command in the output file
		count_local=1
		echo $COMMAND >> $OUTPUT_FILE
		COMMAND="gnome-terminal --window --title $basename_local --command=\"$command_local\""
	else
		COMMAND=$COMMAND" --tab --title $basename_local --command=\"$command_local\""
	fi
	echo $file_local
done

#Save command to file
echo $COMMAND >> $OUTPUT_FILE
#Launch all the commands created in the output file
bash $OUTPUT_FILE

#then clean up this file
rm $OUTPUT_FILE
exit 0
