#!/bin/bash
#--------------------------------------------------------------------------
# pg_compile
#	Copy and compile PostgreSQL or Postgres-XC code
#	Copyright (c) 2010-2013, Michael Paquier
#
#	The code used for compilation is a copy of an original code.
#	Run regressions if necessary or enforce debug flag.
#--------------------------------------------------------------------------

# Take and check options
EXPECTED_ARGS=0
FLAG_DEBUG=0
FLAG_REGRESS=0
FLAG_PATH=0
# VPATH and code copy flags
FLAG_INPUT_FOLDER=0
FLAG_OUTPUT_FOLDER=0
FLAG_VPATH=0
FLAG_NORMAL=0
FLAG_COPY_ONLY=0
FLAG_TAG=0
FLAG_CONTRIB=0

# Show help
show_help()
{
	ERROR_NUM=$1
	echo "Usage: `basename $0` [OPTION]..."
	echo " "
	echo "Options:"
	echo "  -d       Compile with debug flag"
	echo "  -h       Show this help"
	echo "  -m       Include contrib modules in installation"
	echo "  -p PATH  Define installation folder"
	echo "  -r       Run regressions"
	echo " "
	echo "Code copy for installation:"
	echo "  -c       Copy only code, no installation"
	echo "  -i PATH  Original code folder (input)"
	echo "  -o PATH  install folder (output)"
	echo "  -n       Normal installation"
	echo "  -v       VPATH installation"
	echo " "
	echo "Code synchronization options"
	echo "  -b BRANCH"
	echo "           Sync output code at latest point of given branch"
	echo "           This is incompatible with VPATH installation"
	echo "  -t SHA1 or TAG"
	echo "           Sync output code up to given Git tag or commit"
	echo "           If nothing is specified current code of"
	echo "           input directory is used. This gives priority"
	echo "           to commit/tag so modified code is removed."
	echo "           This is incompatible with VPATH installation"

	exit $ERROR_NUM
}

# Update local Git repository to commit or tag
update_code_to_commit()
{
	UPDATE_TO_COMMIT=$1

	# First check if given entry given by user is a valid tag
	CHECKED_COMMIT_ID=`git show-ref --hash $UPDATE_TO_COMMIT`
	RES=$?
	if [ "$RES" != 0 ]
	then
		echo "$UPDATE_TO_COMMIT is not a valid tag, falling back to SHA1 commit check"
		CHECKED_COMMIT_ID=$UPDATE_TO_COMMIT
	fi

	# Now check if the converted commit exists, in the case of a tag already
	# validated, this cannot happen, but the 1st step might fail, so double
	# check
	git log $CHECKED_COMMIT_ID &> /dev/null
	RES=$?
	if [ "$RES" != 0 ]
	then
		echo "$UPDATE_TO_COMMIT is not a valid commit ID"
		exit $RES
	fi

	echo "Aligning code with commit $CHECKED_COMMIT_ID"

	# Store existing code if any
	git stash -q
	git stash clear &> /dev/null

	git branch tmp_$UPDATE_TO_COMMIT $CHECKED_COMMIT_ID &> /dev/null
	git checkout tmp_$UPDATE_TO_COMMIT &> /dev/null
}

# Update local Git repository to latest point of given branch
# This could actually use update_code_to_commit but it looks cleaner
# to check if the branch specified actually exists and then check it out
# without creating a new one.
update_code_to_branch()
{
	UPDATE_TO_BRANCH=$1

	git show-ref --quiet $UPDATE_TO_BRANCH
	RES=$?
	# Branch does not exist
	if [ "$RES" != 0 ]
	then
		echo "$UPDATE_TO_BRANCH is not an existing local branch"
		exit $RES
	fi

	echo "Aligning code with latest commit in branch $UPDATE_TO_BRANCH"

	# Store existing code if any
	git stash -q
	git stash clear &> /dev/null

	# Then checkout the stuff
	git checkout $UPDATE_TO_BRANCH &> /dev/null
}

#Treat options
while getopts 'b:cdhi:mno:p:rt:v' OPTION
do
	case $OPTION in
	b)	# Branch to sync code with
		FLAG_BRANCH=1
		USER_GIT_BRANCH="$OPTARG"
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		;;
	c)	# Copy only code, no installation
		FLAG_COPY_ONLY=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	d)	# Enforce debug flag
		FLAG_DEBUG=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	h)	# Help
		show_help 0
		;;
	i)	# Folder where to install code with vpath
		FLAG_INPUT_FOLDER=1
		USER_INPUT_FOLDER="$OPTARG"
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		;;
	m)	# Include contrib modules in install
		FLAG_CONTRIB=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	n)	# Normal installation flag
		FLAG_NORMAL=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	o)	# Folder where original code is located -- vpath install
		FLAG_OUTPUT_FOLDER=1
		USER_OUTPUT_FOLDER="$OPTARG"
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		;;
	p)	# Installation folder
		FLAG_PATH=1
		USER_INSTALL_FOLDER="$OPTARG"
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		;;
	r)	# Run regressions
		FLAG_REGRESS=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	t)	# Get code up to tag or commit ID
		FLAG_TAG=1
		USER_GIT_COMMIT_TAG="$OPTARG"
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		;;
	v)	# VPATH flag
		FLAG_VPATH=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	?)	# Help
		show_help 1
		;;
	esac
done

# Check number of arguments
if [ $# -ne $EXPECTED_ARGS ]
then
	show_help 1
fi

# Check option compatibility
# Leave an error if both normal and vpath installation are wanted
if [ "$FLAG_VPATH" == 1 -a "$FLAG_NORMAL" == 1 ]
then
	echo "Cannot do VPATH and normal installation at the same time"
	exit 1
fi
# Leave error if input and output are precised without an installation flag
if [ "$FLAG_OUTPUT_FOLDER" == 1 -a "$FLAG_VPATH" == 0 -a "$FLAG_NORMAL" == 0 ]
then
	echo "Cannot define output folder without installation flag activated"
	exit 1
fi
if [ "$FLAG_INPUT_FOLDER" == 1 -a "$FLAG_VPATH" == 0 -a "$FLAG_NORMAL" == 0 ]
then
	echo "Cannot define input folder without installation flag activated"
	exit 1
fi
# No installation flags can be used when copy-only is activated
if [ "$FLAG_COPY_ONLY" == 1 ]
then
	if [ "$FLAG_VPATH" == 1 -o "$FLAG_NORMAL" == 1 -o "$FLAG_CONTRIB" == 1 ]
	then
		echo "Cannot do install when copy-only is activated"
		exit 1
	fi
fi
# VPATH installation is incompatible with commit and branch settings as the
# output folder is updated in this case, but VPATH has actually no GIT tree
# to use.
if [ "$FLAG_VPATH" == 1 ]
then
	if [ "$FLAG_TAG" == 1 ]
	then
		echo "Cannot use tag/commit specification on VPATH install"
		exit 1
	fi
	if [ "$FLAG_BRANCH" == 1 ]
	then
		echo "Cannot use branch specification on VPATH install"
		exit 1
	fi
fi
# Branch and commit specifications cannot be used at the same time
if [ "$FLAG_TAG" == 1 -a "$FLAG_BRANCH" == 1 ]
then
	echo "Cannot specify both branch and commit/tag specification"
	exit 1
fi

# Set input folder value
if [ "$FLAG_INPUT_FOLDER" == 1 ]
then
	PSQL_INPUT_FOLDER=$USER_INPUT_FOLDER
else
	# Use global source folder as default
	PSQL_INPUT_FOLDER=$HOME_POSTGRES_SRC
	if [ "$FLAG_VPATH" == 1 -o "$FLAG_NORMAL" == 1 ]
	then
		echo "Using default input folder $PSQL_INPUT_FOLDER"
	fi
fi
# Set output folder value
if [ "$FLAG_OUTPUT_FOLDER" == 1 ]
then
	PSQL_OUTPUT_FOLDER=$USER_OUTPUT_FOLDER
else
	# Enforce creation of global make folder if it does not exist
	if [ ! -d $HOME_GLOBAL_MAKE ]
	then
		mkdir $HOME_GLOBAL_MAKE
		echo "Creating global make folder $HOME_GLOBAL_MAKE"
	fi

	# Use global make folder as default
	PSQL_OUTPUT_FOLDER=$HOME_POSTGRES_MAKE
	if [ "$FLAG_VPATH" == 1 -o "$FLAG_NORMAL" == 1 ]
	then
		echo "Using default output folder $PSQL_OUTPUT_FOLDER"
	fi
fi

# Define installation folder
if [ "$FLAG_PATH" == 1 ]
then
	PSQL_INSTALL_FOLDER=$USER_INSTALL_FOLDER
else
	# Use global install folder as default
	PSQL_INSTALL_FOLDER=$HOME_POSTGRES_INSTALL

	# Print message only if installation method is specified
	if [ "$FLAG_VPATH" == 1 -o "$FLAG_NORMAL" == 1 ]
	then
		echo "Using default installation folder $PSQL_INSTALL_FOLDER"
	fi
fi

# If normal or vpath install flags are activated, we need to copy the code first
if [ "$FLAG_VPATH" == 1 -o "$FLAG_NORMAL" == 1 ]
then
	# Clean up the output folder if it already exists
	if [ -d $PSQL_OUTPUT_FOLDER ]
	then
		rm -rf $PSQL_OUTPUT_FOLDER
		echo "Deleting existing output folder $PSQL_OUTPUT_FOLDER"
	fi

	# If VPATH installation is activated, we need to call configure currently
	# located in the input folder directly in the output folder
	if [ "$FLAG_VPATH" == 1 ]
	then
		# Case of a VPATH installation

		# Then move in the output folder and launch configure in input folder
		mkdir $PSQL_OUTPUT_FOLDER
		cd $PSQL_OUTPUT_FOLDER
		CONFIGURE_CALL_FOLDER=$PSQL_INPUT_FOLDER
	else
		# Case of a normal installation, here calling configure from the local
		# folder is enough. But first copy code.
		cp -r $PSQL_INPUT_FOLDER $PSQL_OUTPUT_FOLDER
		cd $PSQL_OUTPUT_FOLDER

		# Update code to given tag
		if [ "$FLAG_TAG" == 1 ]
		then
			update_code_to_commit $USER_GIT_COMMIT_TAG
		fi
		# Update code to given branch
		if [ "$FLAG_BRANCH" == 1 ]
		then
			update_code_to_branch $USER_GIT_BRANCH
		fi

		CONFIGURE_CALL_FOLDER="."
	fi

	# Check the presence of configure in given folder
	if [ ! -x $CONFIGURE_CALL_FOLDER/configure ]
	then
		echo "No configure in folder $CONFIGURE_CALL_FOLDER"
		exit 1
	fi

	# Configure Postgres install folder
	if [ "$FLAG_DEBUG" == 1 ]
	then
		$CONFIGURE_CALL_FOLDER/configure --prefix=$PSQL_INSTALL_FOLDER --enable-depend --enable-debug --disable-rpath --enable-cassert --with-libxml CFLAGS="-DG"
	else
		$CONFIGURE_CALL_FOLDER/configure --prefix=$PSQL_INSTALL_FOLDER --enable-depend --enable-debug --disable-rpath --enable-cassert --with-libxml
	fi
elif [ "$FLAG_COPY_ONLY" == 1 ]
then
	# Perform a copy-only

	# Clean up the output folder if it already exists
	if [ -d $PSQL_OUTPUT_FOLDER ]
	then
		rm -rf $PSQL_OUTPUT_FOLDER
		echo "Deleting existing output folder $PSQL_OUTPUT_FOLDER"
	fi

	# Then do the copy
	cp -r $PSQL_INPUT_FOLDER $PSQL_OUTPUT_FOLDER
	echo "Copying source folder $PSQL_INPUT_FOLDER to $PSQL_OUTPUT_FOLDER"

	# exit, no installation is necessary
	exit 0
else
	# Configure folder is the current folder here
	CONFIGURE_CALL_FOLDER="."

	# Check the presence of configure in given folder
	if [ ! -x $CONFIGURE_CALL_FOLDER/configure ]
	then
		echo "No configure in folder $CONFIGURE_CALL_FOLDER"
		exit 1
	fi

	# Update code to given tag
	if [ "$FLAG_TAG" == 1 ]
	then
		update_code_to_commit $USER_GIT_COMMIT_TAG
	fi
	# Update code to given branch
	if [ "$FLAG_BRANCH" == 1 ]
	then
		update_code_to_branch $USER_GIT_BRANCH
	fi

	# We do here a normal install, so do not worry about anything with code copy
	if [ "$FLAG_DEBUG" == 1 ]
	then
		./configure --prefix=$PSQL_INSTALL_FOLDER --enable-depend --enable-debug --disable-rpath --enable-cassert --with-libxml CFLAGS="-DG"
	else
		./configure --prefix=$PSQL_INSTALL_FOLDER --enable-depend --enable-debug --disable-rpath --enable-cassert --with-libxml
	fi
fi

# Compile, by being here we certify that we are already in the compilation
# folder
make

# Run regressions if necessary
if [ "$FLAG_REGRESS" == 1 ]
then
	make check
fi

# Install
make install

# Install contrib modules if requested
if [ "$FLAG_CONTRIB" == 1 ]
then
	echo "Installing contrib modules"
	cd contrib/
	make
	make install
fi
