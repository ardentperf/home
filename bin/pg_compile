#!/bin/bash
#--------------------------------------------------------------------------
# pg_compile
#	Copy and compile PostgreSQL or Postgres-XC code
#	Copyright (c) 2010-2014, Michael Paquier
#
#	The code used for compilation is a copy of an original code.
#	Run regressions if necessary or compile contrib modules.
#--------------------------------------------------------------------------

# Immediately leave in case of failure
set -e

# Take and check options
EXPECTED_ARGS=0
FLAG_CCACHE=0
FLAG_REGRESS=0
FLAG_PATH=0
FLAG_BRANCH=0
# VPATH and code copy flags
FLAG_SRC_FOLDER=0
FLAG_TAG=0
FLAG_CONTRIB=0

# Show help
show_help()
{
	ERROR_NUM=$1
	echo "Usage: `basename $0` [OPTION]..."
	echo " "
	echo "Options:"
	echo "  -e NAME  ccache code in given subpath"
	echo "  -h       Show this help"
	echo "  -m       Include contrib modules in installation"
	echo "  -p PATH  Define installation folder"
	echo "  -r       Run regressions"
	echo " "
	echo "Code copy for installation:"
	echo "  -i PATH  Original code folder (source)"
	echo " "
	echo "Code synchronization options"
	echo "  -b BRANCH"
	echo "           Sync source code with latest point of given branch"
	echo "  -o REMOTE"
	echo "           Name of the remote to sync branches with. Value is"
	echo "           ignored if no branches are specified."
	echo "  -t SHA1 or TAG"
	echo "           Sync output code up to given Git tag or commit"
	echo "           If nothing is specified current code of"
	echo "           input directory is used. This gives priority"
	echo "           to commit/tag so modified code is removed."

	exit $ERROR_NUM
}

# Update local Git repository to commit or tag
update_code_to_commit()
{
	UPDATE_TO_COMMIT=$1

	# First check if given entry given by user is a valid tag
	CHECKED_COMMIT_ID=`git show-ref --hash $UPDATE_TO_COMMIT`
	RES=$?
	if [ "$RES" != 0 ]
	then
		echo "$UPDATE_TO_COMMIT is not a valid tag, falling back to SHA1 commit check"
		CHECKED_COMMIT_ID=$UPDATE_TO_COMMIT
	fi

	# Now check if the converted commit exists, in the case of a tag already
	# validated, this cannot happen, but the 1st step might fail, so double
	# check
	git log $CHECKED_COMMIT_ID &> /dev/null
	RES=$?
	if [ "$RES" != 0 ]
	then
		echo "$UPDATE_TO_COMMIT is not a valid commit ID"
		exit $RES
	fi

	echo "Aligning code with commit $CHECKED_COMMIT_ID"

	# Store existing code if any
	git stash -q
	git stash clear &> /dev/null

	git branch tmp_$UPDATE_TO_COMMIT $CHECKED_COMMIT_ID &> /dev/null
	git checkout tmp_$UPDATE_TO_COMMIT &> /dev/null
}

# Update local Git repository to latest point of given branch
# This could actually use update_code_to_commit but it looks cleaner
# to check if the branch specified actually exists and then check it out
# without creating a new one.
update_code_to_branch()
{
	UPDATE_TO_BRANCH=$1
	UPDATE_TO_REMOTE=$2

	git show-ref --quiet $UPDATE_TO_BRANCH
	RES=$?
	# Branch does not exist
	if [ "$RES" != 0 ]
	then
		echo "$UPDATE_TO_BRANCH is not an existing local branch"
		exit $RES
	fi

	echo "Aligning code with latest commit in branch $UPDATE_TO_BRANCH"

	# Store existing code if any
	git stash -q
	git stash clear &> /dev/null

	# Then checkout the stuff
	git checkout $UPDATE_TO_BRANCH &> /dev/null

	# Update to latest point defined by remote
	git merge $UPDATE_TO_REMOTE/$UPDATE_TO_BRANCH
}

# Default values
USER_GIT_REMOTE="origin"

#Treat options
while getopts 'b:de:h:mo:p:rt:' OPTION
do
	case $OPTION in
	b)	# Branch to sync code with
		FLAG_BRANCH=1
		USER_GIT_BRANCH="$OPTARG"
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		;;
	e)	# Enable ccache
		FLAG_CCACHE=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		CCACHE_NAME="$OPTARG"
		;;
	h)	# Help
		show_help 0
		;;
	m)	# Include contrib modules in install
		FLAG_CONTRIB=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	o)	# Remote to sync branches with
		USER_GIT_REMOTE="$OPTARG"
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		;;
	p)	# Installation folder
		FLAG_PATH=1
		USER_INSTALL_FOLDER="$OPTARG"
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		;;
	r)	# Run regressions
		FLAG_REGRESS=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	t)	# Get code up to tag or commit ID
		FLAG_TAG=1
		USER_GIT_COMMIT_TAG="$OPTARG"
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		;;
	?)	# Help
		show_help 1
		;;
	esac
done

# Check number of arguments
if [ $# -ne $EXPECTED_ARGS ]
then
	show_help 1
fi

# Branch and commit specifications cannot be used at the same time
if [ "$FLAG_TAG" == 1 -a "$FLAG_BRANCH" == 1 ]
then
	echo "Cannot specify both branch and commit/tag specification"
	exit 1
fi

# Set input folder value
if [ "$FLAG_SRC_FOLDER" == 1 ]
then
	PSQL_SRC_FOLDER=$USER_INPUT_FOLDER
else
	# Use global source folder as default
	PSQL_SRC_FOLDER=$HOME_POSTGRES_SRC
	echo "Using default input folder $PSQL_SRC_FOLDER"
fi

# Define installation folder
if [ "$FLAG_PATH" == 1 ]
then
	PSQL_INSTALL_FOLDER=$USER_INSTALL_FOLDER
else
	# Use global install folder as default
	PSQL_INSTALL_FOLDER=$HOME_POSTGRES_INSTALL
	echo "Using default installation folder $PSQL_INSTALL_FOLDER"
fi

# General options for configure
CONFIGURE_OPTIONS="--enable-depend --enable-debug --disable-rpath"
CONFIGURE_OPTIONS="$CONFIGURE_OPTIONS --enable-cassert --with-libxml"
CONFIGURE_OPTIONS="$CONFIGURE_OPTIONS --prefix=$PSQL_INSTALL_FOLDER"

# CFLAGS for compiler options
CFLAGS_DATA="-DG -fno-omit-frame-pointer"

# Perform configure, build and installation, here calling configure from
# the local folder is enough.
cd $PSQL_SRC_FOLDER

# Configure folder is the base folder of git tree
CONFIGURE_CALL_FOLDER=`git rev-parse --show-toplevel`

# Update code to given tag if necessary
if [ "$FLAG_TAG" == 1 ]
then
	update_code_to_commit $USER_GIT_COMMIT_TAG
fi
# Update code to given branch
if [ "$FLAG_BRANCH" == 1 ]
then
	update_code_to_branch $USER_GIT_BRANCH $USER_GIT_REMOTE
fi

# Move to base folder of git tree to not trigger VPATH install
cd $CONFIGURE_CALL_FOLDER

# Kick configure
if [ "$FLAG_CCACHE" == 1 ]
then
	./configure CC="ccache gcc" CCACHE_DIR=$HOME_CCACHE_DIR/$CCACHE_NAME \
		$CONFIGURE_OPTIONS CFLAGS="$CFLAGS_DATA"
else
	./configure $CONFIGURE_OPTIONS CFLAGS="$CFLAGS_DATA"
fi

# Compile...
make

# Run regressions if necessary
if [ "$FLAG_REGRESS" == 1 ]
then
	make check
fi

# Install
make install

# Install contrib modules if requested
if [ "$FLAG_CONTRIB" == 1 ]
then
	echo "Installing contrib modules"
	cd contrib/
	make
	make install
fi
