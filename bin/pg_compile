#!/bin/bash
#--------------------------------------------------------------------------
# pg_compile
#	Copy and compile PostgreSQL or Postgres-XC code
#	Copyright (c) 2010-2012, Michael Paquier
#
#	The code used for compilation is a copy of an original code.
#	Run regressions if necessary or enforce debug flag.
#--------------------------------------------------------------------------

# Take and check options
EXPECTED_ARGS=0
FLAG_DEBUG=0
FLAG_REGRESS=0
FLAG_PATH=0
# VPATH and code copy flags
FLAG_INPUT_FOLDER=0
FLAG_OUTPUT_FOLDER=0
FLAG_VPATH=0
FLAG_NORMAL=0
FLAG_COPY_ONLY=0

# Show help
show_help()
{
	ERROR_NUM=$1
	echo "Usage: `basename $0` [OPTION]..."
	echo " "
	echo "Options:"
	echo "  -d       Compile with debug flag"
	echo "  -h       Show this help"
	echo "  -p PATH  Define installation folder"
	echo "  -r       Run regressions"
	echo " "
	echo "Code copy for installation:"
	echo "  -c       Copy only code, no installation"
	echo "  -i PATH  Original code folder (input)"
	echo "  -o PATH  install folder (output)"
	echo "  -n       Normal installation"
	echo "  -v       VPATH installation"
	exit $ERROR_NUM
}

#Treat options
while getopts 'cdhi:no:p:rv' OPTION
do
	case $OPTION in
	c)	# Copy only code, no installation
		FLAG_COPY_ONLY=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	d)	# Enforce debug flag
		FLAG_DEBUG=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	h)	# Help
		show_help 0
		;;
	i)	# Folder where to install code with vpath
		FLAG_INPUT_FOLDER=1
		USER_INPUT_FOLDER="$OPTARG"
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		;;
	n)	# Normal installation flag
		FLAG_NORMAL=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	o)	# Folder where original code is located -- vpath install
		FLAG_OUTPUT_FOLDER=1
		USER_OUTPUT_FOLDER="$OPTARG"
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		;;
	p)	# Installation folder
		FLAG_PATH=1
		USER_INSTALL_FOLDER="$OPTARG"
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 2))
		;;
	r)	# Run regressions
		FLAG_REGRESS=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	v)	# VPATH flag
		FLAG_VPATH=1
		EXPECTED_ARGS=$(($EXPECTED_ARGS + 1))
		;;
	?)	# Help
		show_help 1
		;;
	esac
done

# Check number of arguments
if [ $# -ne $EXPECTED_ARGS ]
then
	show_help 1
fi

# Check option compatibility
# Leave an error if both normal and vpath installation are wanted
if [ "$FLAG_VPATH" == 1 -a "$FLAG_NORMAL" == 1 ]
then
	echo "Cannot do VPATH and normal installation at the same time"
	exit 1
fi
# Leave error if input and output are precised without an installation flag
if [ "$FLAG_OUTPUT_FOLDER" == 1 -a "$FLAG_VPATH" == 0 -a "$FLAG_NORMAL" == 0 ]
then
	echo "Cannot define output folder without installation flag activated"
	exit 1
fi
if [ "$FLAG_INPUT_FOLDER" == 1 -a "$FLAG_VPATH" == 0 -a "$FLAG_NORMAL" == 0 ]
then
	echo "Cannot define input folder without installation flag activated"
	exit 1
fi
# No installation flags can be used when copy-only is activated
if [ "$FLAG_COPY_ONLY" == 1 ]
then
	if [ "$FLAG_VPATH" == 1 -o "$FLAG_NORMAL" == 1 ]
	then
		echo "Cannot do install when copy-only is activated"
		exit 1
	fi
fi

# Set input folder value
if [ "$FLAG_INPUT_FOLDER" == 1 ]
then
	PSQL_INPUT_FOLDER=$USER_INPUT_FOLDER
else
	PSQL_INPUT_FOLDER=$HOME/git/postgres
	if [ "$FLAG_VPATH" == 1 -o "$FLAG_NORMAL" == 1 ]
	then
		echo "Using default input folder $PSQL_INPUT_FOLDER"
	fi
fi
# Set output folder value
if [ "$FLAG_OUTPUT_FOLDER" == 1 ]
then
	PSQL_OUTPUT_FOLDER=$USER_OUTPUT_FOLDER
else
	PSQL_OUTPUT_FOLDER=$HOME/make
	if [ "$FLAG_VPATH" == 1 -o "$FLAG_NORMAL" == 1 ]
	then
		echo "Using default output folder $PSQL_OUTPUT_FOLDER"
	fi
fi

# Define installation folder
if [ "$FLAG_PATH" == 1 ]
then
	PSQL_INSTALL_FOLDER=$USER_INSTALL_FOLDER
else
	PSQL_INSTALL_FOLDER=$HOME/pgsql
	echo "Using default installation folder $PSQL_INSTALL_FOLDER"
fi

# If normal or vpath install flags are activated, we need to copy the code first
if [ "$FLAG_VPATH" == 1 -o "$FLAG_NORMAL" == 1 ]
then
	# Clean up the output folder if it already exists
	if [ -d $PSQL_OUTPUT_FOLDER ]
	then
		rm -rf $PSQL_OUTPUT_FOLDER
		echo "Deleting existing output folder $PSQL_OUTPUT_FOLDER"
	fi

	# If VPATH installation is activated, we need to call configure currently
	# located in the input folder directly in the output folder
	if [ "$FLAG_VPATH" == 1 ]
	then
		# Case of a VPATH installation

		# Then move in the output folder and launch configure in input folder
		mkdir $PSQL_OUTPUT_FOLDER
		cd $PSQL_OUTPUT_FOLDER
		CONFIGURE_CALL_FOLDER=$PSQL_INPUT_FOLDER
	else
		# Case of a normal installation, here calling configure from the local
		# folder is enough. But first copy code.
		cp -r $PSQL_INPUT_FOLDER $PSQL_OUTPUT_FOLDER
		cd $PSQL_OUTPUT_FOLDER
		CONFIGURE_CALL_FOLDER="."
	fi

	# Configure Postgres install folder
	if [ "$FLAG_DEBUG" == 1 ]
	then
		$CONFIGURE_CALL_FOLDER/configure --prefix=$PSQL_INSTALL_FOLDER --enable-depend --enable-debug --disable-rpath --enable-cassert --with-libxml CFLAGS="-DG"
	else
		$CONFIGURE_CALL_FOLDER/configure --prefix=$PSQL_INSTALL_FOLDER --enable-depend --enable-debug --disable-rpath --enable-cassert --with-libxml
	fi
elif [ "$FLAG_COPY_ONLY" == 1 ]
then
	# Perform a copy-only

	# Clean up the output folder if it already exists
	if [ -d $PSQL_OUTPUT_FOLDER ]
	then
		rm -rf $PSQL_OUTPUT_FOLDER
		echo "Deleting existing output folder $PSQL_OUTPUT_FOLDER"
	fi

	# Then do the copy
	cp -r $PSQL_INPUT_FOLDER $PSQL_OUTPUT_FOLDER
	echo "Copying source folder $PSQL_INPUT_FOLDER to $PSQL_OUTPUT_FOLDER"

	# exit, no installation is necessary
	exit 0
else
	# We do here a normal install, so do not worry about anything with code copy
	if [ "$FLAG_DEBUG" == 1 ]
	then
		./configure --prefix=$PSQL_INSTALL_FOLDER --enable-depend --enable-debug --disable-rpath --enable-cassert --with-libxml CFLAGS="-DG"
	else
		./configure --prefix=$PSQL_INSTALL_FOLDER --enable-depend --enable-debug --disable-rpath --enable-cassert --with-libxml
	fi
fi

# Compile, by being here we certify that we are already in the compilation
# folder
make

# Run regressions if necessary
if [ "$FLAG_REGRESS" == 1 ]
then
	make check
fi

# Install
make install
